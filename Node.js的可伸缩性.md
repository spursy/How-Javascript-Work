文章翻译子[Scaling Node.js Applications](https://medium.freecodecamp.org/scaling-node-js-applications-8492bd8afadc)

*你应该知道所有关于Node.js的可伸缩性*

![scalability.png](https://user-gold-cdn.xitu.io/2018/4/19/162dce6d989ae69c?w=1480&h=668&f=png&s=145092)

可伸缩性并不是扩展Node.js应用的第三方包，它是Javascript运行时环境(Node.js)的核心功能。Node.js取名为节点(Node)，这强调Node.js应用可以是相互通信的分布式节点产生向外提供服务。

你是否将你的Node.js应用部署在多个微服务上？你是否为生产环境cpu的每一个内核启动一个Node.js进程？你是否对已经启动的Node.js进程做负载均衡？你是否知道Node.js的内置模块可以帮助你实现上述功能？

Node.js集群(cluster)模块不仅为充分利用服务器cpu提供一种开箱即用的解决方案，而且用来提升Node.js进程的性能，还可以在零停机的时间内重启服务器。这边文章不仅涵盖上述所有内容，而且还有更多鲜为人知的知识。


## 集群的策略

负载均衡是对应用做集群的主要原因，但是并不是唯一原因。对程序做负载均衡不仅增强应用的可用性，而且提高对Node.js应用的生命力(不会因为单个Node.js进程阻塞，而使Node.js应用死亡)。

#### 克隆

提供应用可伸缩性的最简单方式是将应用克隆很多次，将克隆后的应用一起分担外部的数据请求(负载均衡)。这种策略不会增加开发的时间，但是很高效。使用Node.js的cluster(集群)模块，可以是开发者通过最小的开发量对单进程的服务实现克隆策略。

#### 分解

根据应用的功能或者服务对应用进行分解的策略，从而提供程序的伸缩性。这就意味着将会有多个应用程序，这些应用程序可能由不同的代码构成、连接不同数据库和对外提供不同API接口的应用。

这个策略通常是将多个微服务联合在一起，其中“微”的字面意思是服务尽可能的小。在现实场景下，服务的大小并不是最重要的。但是各个服务必须是高内聚、低耦合的。

这种策略实施起来并不容易，可能长期存在不可预测的异常，但是在开发中充分运用这一特性依旧是非常必要的。

#### 切割

将应用根据切割成多个实例，每个实例仅仅负责一部分应用数据。这种策略也叫做数据库的水平分区或水平分片。数据分区在操作前需要进行一次查表，通过查询的结果，调用相应的应用。例如：根据用户的国家或语言切割用户，在每次调用数居前，要去查询用户的国家或者用户的语言。

使大型应用具备可伸缩性，最终都会使用上述三种策略。Node.js可以很容易实现上面三种策略，但是在这篇文章中仅仅集中在克隆策略以及对实现克隆Node.js应用的内置工具做一些探索。


**请注意**你在阅读本篇文章前需要对Node.js的子进程有一些必要的了解。如果还没有深入理解，我推荐你阅读我另外一篇文章：

[你应该知道的Node.js子进程](https://juejin.im/post/5ad6b1686fb9a028ce7c1f80)

## 集群模块

集群模块可以对生产环境服务器的多核cpu做负载均衡。集群模块通过子进程模块的fork方法，衍生出与服务器内核数量一致的子进程。当有外部存在向主进程服务的多个请求时，集群模块会将请求均匀分配给衍生子进程。

集群模块是Node.js为开发者提供的在单服务器上通过克隆策略实现应用伸缩性的的“帮助器”。如果你的服务器有足够的资源？如果对服务器增添资源的成本小于添加多台服务器？集群模块将是快速实现克隆策略最好的选择。

即便小服务器也会有多核cpu？即使你不担心你的Node.js服务的负载？你都应该使用集群模块对提高服务的伸缩性和添强服务的容错能力。这一切对于进程管理工具PM2来说，只是在PM2命令后添加一个参数，就可以上述的功能。

本文将着重介绍如何使用Node.js原生模块实现负载均衡：

集群模块的工作原理很简单。开发者先创建一个主进程，然后通过fork方法衍生出多个工作进程，当请求数据时主进程控制子进程的调度。每个工作进程都是应用的一个实例，所有的请求都由主进程分配给子进程处理。


![master.png](https://user-gold-cdn.xitu.io/2018/4/20/162e0de336ab5947?w=2000&h=1125&f=png&s=192886)

主进程使用轮询调度算法(roud-robin algorithm)，对子进程分配请求的任务。除了Windows，所有平台都支持集群模块。开发者还可以通过全局修改实现自定义的调度算法。

轮询调度算法(roud-robin-algorithm)虚拟所有可用进程首尾相接形成圆，第一个请求分配给圆上第一个子进程，第二个请求分配给圆上第二个子进程，以此类推。当圆上最后一个子进程分配请求后，调度算法将从圆上第一个进程开始分配请求任务。

轮询调度算法是最简单和最实用的调度算法，但是还有其它选择。最有特色的算法是可以根据任务的优先权选择负载最小的进程或响应最快的进程。

#### 对HTTP服务做负载均衡

可以使用集群模块对HTTP服务做负载均衡。下面是对Node.js的hello-word代码做一些简单修改，在响应请求前做大量计算的代码：

```
// server.js
const http = require('http');
const pid = process.pid;

http.createServer((req, res) => {
  for (let i=0; i<1e7; i++); // simulate CPU work
  res.end(`Handled by process ${pid}`);
}).listen(8080, () => {
  console.log(`Started process ${pid}`);
});
```

为了验证我们创建的平衡器是否可以工作，将进程pid放到HTTP响应对象中，根据进程的pid决定哪个子进程处理请求。